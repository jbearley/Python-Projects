# -*- coding: utf-8 -*-
"""Copy of LogisticSequences.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CUuQl4f0cSqKtUFLvARUY6ssKr4r1J9T
"""

#importing the necessary libraries for creating graphs and arrays in Python
import matplotlib.pyplot as plt
import array as arr
import math

#The function logisticSequence stores the population from generation 0 to n in the array called "population", whereas
#the array "nvalues" stores the indexes for each generation, which go from 0 to n.  Once the arrays contain all the necessary elements, a graph will be created
#where the values from the "population" array will be on the y-axis, and the values from the "nvalues" array will be on the x-axis. 
#The parameters of the function will be k, p0, and n, since those are the features that will be changed in the sequence p_n+1 = kp_n(1-p_n) throughout the experiment.
def logisticSequence(k, p0, n):
  index = 0
  nvalues = list(range(n+1))
  population = list(range(n+1))
  population[index] = p0
  for index in range(n):
    nvalues[index] = index
    population[index+1] = (k*population[index])*(1-population[index])
    plt.annotate("Point", (nvalues[index], population[index]))
  
  plt.title("Population as a Function of n")
  plt.xlabel("n")
  plt.ylabel("population")
  
  plt.plot(nvalues, population, 'bo-')
  plt.figure(figsize=(5, 5))
  plt.show()

  for i in range(len(population)):
    print("p",i," = ",population[i],sep='')

#Testing the logisticSequence function to make sure it works exactly like the sequence p_n+1 = kp_n(1-p_n)
#Based on the computational and graphical results, the logisticSequence function works as intended.
print(logisticSequence(0.7, 0.02, 3))

"""# Part 1"""

#Part 1 (a): The first 30 terms will be calculated when p0 = 1/2 with two different values for k
#Let k = 1.5 when p0 = 1/2
print(logisticSequence(1.5, 0.5, 30))

#Let k = 2.5 when p0 = 1/2
print(logisticSequence(2.5, 0.5, 30))

#Part 1 (b): The values of k = 1.5 and k = 2.5 will again be used.  However, they will each be used for two different values of p0.
#Let p0 = 0.25 when k = 1.5
print(logisticSequence(1.5, 0.25, 30))

#Let p0 = 0.25 when k = 2.5
print(logisticSequence(2.5, 0.25, 30))

#Let p0 = 0.75 when k = 1.5
print(logisticSequence(1.5, 0.75, 30))

#Let p0 = 0.75 when k = 2.5
print(logisticSequence(2.5, 0.75, 30))

"""# Part 2"""

#Part 2: For p0 = 1/2, a new k-value will be used
#Let k = 3.2 when p0 = 1/2 and n = 40
print(logisticSequence(3.2, 0.5, 40))

#Let p0 = 0.85 when k is still equal to 3.2 and n is still equal to 40, so that it can be verified that p0 really doesn't have an effect on where the
#sequence p_n+1 = kp_n(1-p_n) converges when 0 < p0 < 1.
print(logisticSequence(3.2, 0.85, 40))

#Let p0 = 0.96 when k is still equal to 3.2 and n is still equal to 40, in order to see if the graph will diverge even less than when p0 = 0.5 and p0 = 0.85
print(logisticSequence(3.2, 0.96, 40))

#Let p0 = 0.12 when k is still equal to 3.2 and n is still equal to 40, in order to see what will happen to the graph when p0 is a value close to 0.
print(logisticSequence(3.2, 0.12, 40))

"""# Part 3"""

#Part 3: There will be nine different k values used, where the k values are between 3.4 and 3.5, where p0 = 1/2 and n = 40.
k = 3.41
while k < 3.5:
  print("k = " + str(k))
  print(logisticSequence(k, 0.5, 40))
  k = k + 0.01

"""# Part 4"""

#Part 4 (a): There will be three different k values used, where the k values are between 3.6 and 4.0, where p0 = 1/2 and n = 100.
k = 3.7
while k < 4:
  print("k = " + str(k))
  print(logisticSequence(k, 0.5, 100))
  k = k + 0.1

#Part 4 (b): There will be three different k values used, where the k values are between 3.6 and 4.0, where p0 will be changed by 0.001.
#Let p0 = 0.5 - 0.001 = 0.499, where all the other parameters will stay the same
k = 3.7
while k < 4:
  print("k = " + str(k))
  print(logisticSequence(k, 0.499, 100))
  k = k + 0.1

#Part 4 (b): There will be three different k values used, where the k values are between 3.6 and 4.0, where p0 will be changed by 0.001.
#Let p0 = 0.5 + 0.001 = 0.501, where all the other parameters will stay the same
k = 3.7
while k < 4:
  print("k = " + str(k))
  print(logisticSequence(k, 0.501, 100))
  k = k + 0.1